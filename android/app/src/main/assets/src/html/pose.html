<!DOCTYPE html>
<html>
  <head>
    <title>Posture Detection</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      http-equiv="Content-Security-Policy"
      content="default-src * 'self' 'unsafe-inline' 'unsafe-eval' data: gap:"
    />

    <!-- TensorFlow.js & Pose Detection -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-cpu"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
  </head>

  <body>
    <script>
      let detector = null;

      // Notify React Native that the WebView is ready
      window.addEventListener("load", () => {
        window.ReactNativeWebView.postMessage(
          JSON.stringify({ type: "log", message: "‚úÖ WebView script loaded!" })
        );
      });

      // Load TFJS with CPU backend and initialize model
      async function prepareModel() {
        try {
          await tf.setBackend("cpu");
          await tf.ready();

          const model = poseDetection.SupportedModels.MoveNet;
          detector = await poseDetection.createDetector(model, {
            modelType: "SinglePose.Lightning",
          });

          window.ReactNativeWebView.postMessage(
            JSON.stringify({
              type: "ready",
              status: "model_ready",
              message: "‚úÖ MoveNet loaded with CPU backend",
              timestamp: Date.now(),
            })
          );
        } catch (err) {
          window.ReactNativeWebView.postMessage(
            JSON.stringify({
              type: "error",
              message: "‚ùå Model init failed: " + err.message,
            })
          );
        }
      }

      function analyzePosture(pose) {
        const keypoints = pose[0]?.keypoints;
        if (!keypoints) return "unknown";

        const leftShoulder = keypoints.find((p) => p.name === "left_shoulder");
        const leftEar = keypoints.find((p) => p.name === "left_ear");

        if (leftShoulder && leftEar) {
          const diff = Math.abs(leftShoulder.y - leftEar.y);
          return diff < 30 ? "good" : "bad";
        }

        return "unknown";
      }

      async function predictPoseFromBase64(base64Image) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.src = base64Image;
          img.crossOrigin = "anonymous";

          img.onload = async () => {
            try {
              if (!detector) {
                const msg = "Detector not initialized";
                window.ReactNativeWebView.postMessage(
                  JSON.stringify({ type: "error", message: msg })
                );
                return reject(msg);
              }

              img.style.display = "none";
              document.body.appendChild(img);

              const pose = await detector.estimatePoses(img);

              const posture = analyzePosture(pose);

              window.ReactNativeWebView.postMessage(
                JSON.stringify({
                  type: "posture_analysis",
                  status: "success",
                  posture,
                  pose,
                  timestamp: Date.now(),
                })
              );

              document.body.removeChild(img);
              resolve(pose);
            } catch (err) {
              window.ReactNativeWebView.postMessage(
                JSON.stringify({
                  type: "error",
                  message: "‚ùå Pose estimation error: " + err.message,
                })
              );
              reject(err);
            }
          };

          img.onerror = () => {
            const msg = "‚ùå Failed to load image";
            window.ReactNativeWebView.postMessage(
              JSON.stringify({ type: "error", message: msg })
            );
            reject(new Error(msg));
          };
        });
      }

      function handleLogMessage(event) {
        try {
          const rawData = event.data;
          const message =
            typeof rawData === "string" ? JSON.parse(rawData) : rawData;

          if (message.command === "predict" && message.image) {
            predictPoseFromBase64(message.image)
              .then(() => {
                window.ReactNativeWebView.postMessage(
                  JSON.stringify({
                    type: "log",
                    message: "‚úÖ Pose prediction completed",
                    timestamp: Date.now(),
                  })
                );
              })
              .catch((err) => {
                window.ReactNativeWebView.postMessage(
                  JSON.stringify({
                    type: "error",
                    message: "‚ùå Prediction failed: " + err.message,
                    timestamp: Date.now(),
                  })
                );
              });
          } else {
            // Generic message logging
            window.ReactNativeWebView.postMessage(
              JSON.stringify({
                type: "log",
                message: message.message || "No message provided",
                from: message.from || "unknown",
                timestamp: Date.now(),
              })
            );
          }
        } catch (err) {
          window.ReactNativeWebView.postMessage(
            JSON.stringify({
              type: "error",
              message: "‚ùå Error in message handler: " + err.message,
              timestamp: Date.now(),
            })
          );
        }
      }

      window.ReactNativeWebView.onMessage = handleLogMessage;
      document.addEventListener("message", handleLogMessage);

      // Notify React Native immediately and start model prep
      window.ReactNativeWebView.postMessage(
        JSON.stringify({
          type: "ping",
          message: "üì° pose.html loaded and ready",
          timestamp: Date.now(),
        })
      );

      prepareModel();
    </script>
  </body>
</html>
